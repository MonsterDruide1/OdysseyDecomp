#pragma once

#include <gfx/seadCamera.h>
#include <math/seadMatrix.h>
#include <math/seadQuat.h>
#include <math/seadVector.h>

namespace al {
class CameraPoser;
struct CameraStartInfo;
struct CameraObjectRequestInfo;
class IUseCollision;
class PlacementInfo;
class Projection;
}  // namespace al

namespace alCameraPoserFunction {
class CameraCollisionHitResult;

s32 getViewIndex(const al::CameraPoser* cameraPoser);
const sead::LookAtCamera& getLookAtCamera(const al::CameraPoser* cameraPoser);
const sead::Projection& getProjectionSead(const al::CameraPoser* cameraPoser);
const al::Projection& getProjection(const al::CameraPoser* cameraPoser);
void getProjectionMtx(const al::CameraPoser* cameraPoser);
f32 getNear(const al::CameraPoser* cameraPoser);
f32 getFar(const al::CameraPoser* cameraPoser);
f32 getAspect(const al::CameraPoser* cameraPoser);
const sead::Vector3f& getPreCameraPos(const al::CameraPoser* cameraPoser);
const sead::Vector3f& getPreLookAtPos(const al::CameraPoser* cameraPoser);
const sead::Vector3f& getPreUpDir(const al::CameraPoser* cameraPoser);
f32 getPreFovyDegree(const al::CameraPoser* cameraPoser);
f32 getPreFovyRadian(const al::CameraPoser* cameraPoser);
bool isPrePriorityDemo(const al::CameraStartInfo& cameraStartInfo);
bool isPrePriorityDemo2(const al::CameraStartInfo& cameraStartInfo);
bool isPrePriorityDemoTalk(const al::CameraStartInfo& cameraStartInfo);
bool isPrePriorityDemoAll(const al::CameraStartInfo& cameraStartInfo);
bool isPrePriorityEntranceAll(const al::CameraStartInfo& cameraStartInfo);
bool isPrePriorityPlayer(const al::CameraStartInfo& cameraStartInfo);
bool isEqualPreCameraName(const al::CameraStartInfo& cameraStartInfo, const char*);
bool isPreCameraFixAbsolute(const al::CameraStartInfo& cameraStartInfo);
bool isInvalidCollidePreCamera(const al::CameraStartInfo& cameraStartInfo);
bool isInvalidKeepPreCameraDistance(const al::CameraStartInfo& cameraStartInfo);
bool isInvalidKeepPreCameraDistanceIfNoCollide(const al::CameraStartInfo& cameraStartInfo);
bool isValidResetPreCameraPose(const al::CameraStartInfo& cameraStartInfo);
bool isValidKeepPreSelfCameraPose(const al::CameraStartInfo& cameraStartInfo);
f32 getPreCameraSwingAngleH(const al::CameraStartInfo& cameraStartInfo);
f32 getPreCameraSwingAngleV(const al::CameraStartInfo& cameraStartInfo);
f32 getPreCameraMaxSwingAngleH(const al::CameraStartInfo& cameraStartInfo);
f32 getPreCameraMaxSwingAngleV(const al::CameraStartInfo& cameraStartInfo);
bool isExistAreaAngleH(const al::CameraStartInfo& cameraStartInfo);
bool isExistAreaAngleV(const al::CameraStartInfo& cameraStartInfo);
f32 getAreaAngleH(const al::CameraStartInfo& cameraStartInfo);
f32 getAreaAngleV(const al::CameraStartInfo& cameraStartInfo);
bool isExistNextPoseByPreCamera(const al::CameraStartInfo& cameraStartInfo);
f32 getNextAngleHByPreCamera(const al::CameraStartInfo& cameraStartInfo);
f32 getNextAngleVByPreCamera(const al::CameraStartInfo& cameraStartInfo);
void calcCameraPose(sead::Quatf* out, const al::CameraPoser* cameraPoser);
void calcLookDir(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcCameraDir(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcCameraDirH(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
bool calcLookDirH(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcSideDir(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcPreCameraDir(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcPreCameraDirH(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcPreLookDir(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcPreLookDirH(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
f32 calcPreCameraAngleH(const al::CameraPoser* cameraPoser);
f32 calcPreCameraAngleV(const al::CameraPoser* cameraPoser);
void setLookAtPosToTarget(al::CameraPoser* cameraPoser);
void calcTargetTrans(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void setLookAtPosToTargetAddOffset(al::CameraPoser* cameraPoser, const sead::Vector3f& offset);
void setCameraPosToTarget(al::CameraPoser* cameraPoser);
void setCameraPosToTargetAddOffset(al::CameraPoser* cameraPoser, const sead::Vector3f& offset);
void calcTargetTransWithOffset(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcTargetVelocity(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcTargetVelocityH(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcTargetUp(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
f32 calcTargetSpeedV(const al::CameraPoser* cameraPoser);
void calcTargetPose(sead::Quatf* out, const al::CameraPoser* cameraPoser);
void calcTargetFront(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcTargetSide(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcTargetGravity(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
f32 calcTargetSpeedH(const al::CameraPoser* cameraPoser);
f32 calcTargetJumpSpeed(const al::CameraPoser* cameraPoser);
f32 calcTargetFallSpeed(const al::CameraPoser* cameraPoser);
bool isChangeTarget(const al::CameraPoser* cameraPoser);
bool tryGetTargetRequestDistance(f32* out, const al::CameraPoser* cameraPoser);
f32* tryGetBossDistanceCurve(const al::CameraPoser* cameraPoser);
f32* tryGetEquipmentDistanceCurve(const al::CameraPoser* cameraPoser);
bool isExistCollisionUnderTarget(const al::CameraPoser* cameraPoser);
const sead::Vector3f& getUnderTargetCollisionPos(const al::CameraPoser* cameraPoser);
const sead::Vector3f& getUnderTargetCollisionNormal(const al::CameraPoser* cameraPoser);
bool isExistSlopeCollisionUnderTarget(const al::CameraPoser* cameraPoser);
bool isExistWallCollisionUnderTarget(const al::CameraPoser* cameraPoser);
bool tryCalcSlopeCollisionDownFrontDirH(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
f32 getSlopeCollisionUpSpeed(const al::CameraPoser* cameraPoser);
f32 getSlopeCollisionDownSpeed(const al::CameraPoser* cameraPoser);
bool isExistSubTarget(const al::CameraPoser* cameraPoser);
bool checkValidTurnToSubTarget(const al::CameraPoser* cameraPoser);
void calcSubTargetBack(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
void calcSubTargetTrans(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
bool isChangeSubTarget(const al::CameraPoser* cameraPoser);
void calcSubTargetFront(sead::Vector3f* out, const al::CameraPoser* cameraPoser);
f32 getSubTargetRequestDistance(const al::CameraPoser* cameraPoser);
f32 getSubTargetTurnSpeedRate1(const al::CameraPoser* cameraPoser);
f32 getSubTargetTurnSpeedRate2(const al::CameraPoser* cameraPoser);
s32 getSubTargetTurnRestartStep(const al::CameraPoser* cameraPoser);
bool tryCalcSubTargetTurnBrakeDistanceRate(f32* out, const al::CameraPoser* cameraPoser);
bool isValidSubTargetTurnV(const al::CameraPoser* cameraPoser);
bool isValidSubTargetResetAfterTurnV(const al::CameraPoser* cameraPoser);
void clampAngleSubTargetTurnRangeV(f32* out, const al::CameraPoser* cameraPoser);
void initCameraVerticalAbsorber(al::CameraPoser* cameraPoser);
void initCameraVerticalAbsorberNoCameraPosAbsorb(al::CameraPoser* cameraPoser);
f32 getCameraVerticalAbsorbPosUp(const al::CameraPoser* cameraPoser);
f32 getCameraVerticalAbsorbPosDown(const al::CameraPoser* cameraPoser);
void liberateVerticalAbsorb(al::CameraPoser* cameraPoser);
void stopUpdateVerticalAbsorb(al::CameraPoser* cameraPoser);
void stopUpdateVerticalAbsorbForSnapShotMode(al::CameraPoser* cameraPoser,
                                             const sead::Vector3f& offset);
void restartUpdateVerticalAbsorb(al::CameraPoser* cameraPoser);
void validateVerticalAbsorbKeepInFrame(al::CameraPoser* cameraPoser);
void invalidateVerticalAbsorbKeepInFrame(al::CameraPoser* cameraPoser);
void setVerticalAbsorbKeepInFrameScreenOffsetUp(al::CameraPoser* cameraPoser, f32 offset);
void setVerticalAbsorbKeepInFrameScreenOffsetDown(al::CameraPoser* cameraPoser, f32 offset);
void initCameraArrowCollider(al::CameraPoser* cameraPoser);
void initCameraArrowColliderWithoutThroughPassCollision(al::CameraPoser* cameraPoser);
void initCameraMoveLimit(al::CameraPoser* cameraPoser);
void initCameraAngleCtrl(al::CameraPoser* cameraPoser);
void initCameraAngleCtrlWithRelativeH(al::CameraPoser* cameraPoser);
void initCameraDefaultAngleRangeV(al::CameraPoser* cameraPoser, f32 min, f32 max);
void setCameraStartAngleV(al::CameraPoser* cameraPoser, f32 angle);
void setCameraAngleV(al::CameraPoser* cameraPoser, f32 angle);
void getCameraAngleH(const al::CameraPoser* cameraPoser);
void getCameraAngleV(const al::CameraPoser* cameraPoser);
void initAngleSwing(al::CameraPoser* cameraPoser);
bool isValidAngleSwing(const al::CameraPoser* cameraPoser);
void initCameraOffsetCtrlPreset(al::CameraPoser* cameraPoser);
void getOffset(const al::CameraPoser* cameraPoser);
void initGyroCameraCtrl(al::CameraPoser* cameraPoser);
void resetGyro(al::CameraPoser* cameraPoser);
void calcCameraGyroPose(const al::CameraPoser* cameraPoser, sead::Vector3f*, sead::Vector3f*,
                        sead::Vector3f*);
void getGyroFront(al::CameraPoser* cameraPoser);
void getGyroAngleV(al::CameraPoser* cameraPoser);
void getGyroAngleH(al::CameraPoser* cameraPoser);
void setGyroLimitAngleV(al::CameraPoser* cameraPoser, f32, f32);
void setGyroSensitivity(al::CameraPoser* cameraPoser, f32, f32);
void reduceGyroSencitivity(al::CameraPoser* cameraPoser);
void stopUpdateGyro(al::CameraPoser* cameraPoser);
void restartUpdateGyro(al::CameraPoser* cameraPoser);
bool isStopUpdateGyro(const al::CameraPoser* cameraPoser);
bool isTargetCollideGround(const al::CameraPoser* cameraPoser);
bool isTargetInWater(const al::CameraPoser* cameraPoser);
bool isTargetInMoonGravity(const al::CameraPoser* cameraPoser);
bool isTargetClimbPole(const al::CameraPoser* cameraPoser);
bool isTargetGrabCeil(const al::CameraPoser* cameraPoser);
bool isTargetInvalidMoveByInput(const al::CameraPoser* cameraPoser);
bool isTargetEnableEndAfterInterpole(const al::CameraPoser* cameraPoser);
bool isTargetWallCatch(const al::CameraPoser* cameraPoser);
bool isSnapShotMode(const al::CameraPoser* cameraPoser);
void initSnapShotCameraCtrl(al::CameraPoser* cameraPoser);
void initSnapShotCameraCtrlZoomAutoReset(al::CameraPoser* cameraPoser);
void initSnapShotCameraCtrlZoomRollMove(al::CameraPoser* cameraPoser);
void validateSnapShotCameraLookAtOffset(al::CameraPoser* cameraPoser);
void validateSnapShotCameraZoomFovy(al::CameraPoser* cameraPoser);
void validateSnapShotCameraRoll(al::CameraPoser* cameraPoser);
void updateSnapShotCameraCtrl(al::CameraPoser* cameraPoser);
void startResetSnapShotCameraCtrl(al::CameraPoser* cameraPoser, s32);
void setSnapShotMaxZoomOutFovyDegree(al::CameraPoser* cameraPoser, f32);
void getSnapShotRollDegree(const al::CameraPoser* cameraPoser);
void getSnapShotLookAtOffset(const al::CameraPoser* cameraPoser);
bool isOffVerticalAbsorb(const al::CameraPoser* cameraPoser);
void onVerticalAbsorb(al::CameraPoser* cameraPoser);
void offVerticalAbsorb(al::CameraPoser* cameraPoser);
void invalidateCameraBlur(al::CameraPoser* cameraPoser);
bool isRequestStopVerticalAbsorb(const al::CameraObjectRequestInfo&);
bool isRequestResetPosition(const al::CameraObjectRequestInfo&);
bool isRequestResetAngleV(const al::CameraObjectRequestInfo&);
bool isRequestDownToDefaultAngleBySpeed(const al::CameraObjectRequestInfo&);
bool isRequestUpToTargetAngleBySpeed(const al::CameraObjectRequestInfo&);
void getRequestTargetAngleV(const al::CameraObjectRequestInfo&);
void getRequestAngleSpeed(const al::CameraObjectRequestInfo&);
bool isRequestMoveDownAngleV(const al::CameraObjectRequestInfo&);
bool isRequestSetAngleV(const al::CameraObjectRequestInfo&);
void getRequestAngleV(const al::CameraObjectRequestInfo&);
bool isInvalidCollider(const al::CameraPoser* cameraPoser);
void validateCollider(al::CameraPoser* cameraPoser);
void invalidateCollider(al::CameraPoser* cameraPoser);
void validateCtrlSubjective(al::CameraPoser* cameraPoser);
void invalidateChangeSubjective(al::CameraPoser* cameraPoser);
void invalidateKeepDistanceNextCamera(al::CameraPoser* cameraPoser);
void invalidateKeepDistanceNextCameraIfNoCollide(al::CameraPoser* cameraPoser);
void invalidatePreCameraEndAfterInterpole(al::CameraPoser* cameraPoser);
bool isInvalidPreCameraEndAfterInterpole(const al::CameraPoser* cameraPoser);
bool isSceneCameraFirstCalc(const al::CameraPoser* cameraPoser);
bool isActiveInterpole(const al::CameraPoser* cameraPoser);
bool isInvalidEndEntranceCamera(const al::CameraPoser* cameraPoser);
bool isPause(const al::CameraPoser* cameraPoser);
void checkFirstCameraCollisionArrow(sead::Vector3f*, sead::Vector3f*, const al::IUseCollision*,
                                    const sead::Vector3f&, const sead::Vector3f&);
void checkFirstCameraCollisionArrow(CameraCollisionHitResult*, const al::IUseCollision*,
                                    const sead::Vector3f&, const sead::Vector3f&);
void checkFirstCameraCollisionArrowOnlyCeiling(sead::Vector3f*, sead::Vector3f*,
                                               const al::IUseCollision*, const sead::Vector3f&,
                                               const sead::Vector3f&);
void checkCameraCollisionMoveSphere(sead::Vector3f*, const al::IUseCollision*,
                                    const sead::Vector3f&, const sead::Vector3f&, f32);
f32 calcZoneRotateAngleH(f32, const al::CameraPoser* cameraPoser);
f32 calcZoneRotateAngleH(f32, const sead::Matrix34f&);
f32 calcZoneInvRotateAngleH(f32, const sead::Matrix34f&);
void multVecZone(sead::Vector3f*, const sead::Vector3f&, const al::CameraPoser* cameraPoser);
void multVecInvZone(sead::Vector3f*, const sead::Vector3f&, const al::CameraPoser* cameraPoser);
void rotateVecZone(sead::Vector3f*, const sead::Vector3f&, const al::CameraPoser* cameraPoser);
void calcOffsetCameraKeepInFrameV(sead::Vector3f*, sead::LookAtCamera*, const sead::Vector3f&,
                                  const al::CameraPoser* cameraPoser, f32, f32);
void makeCameraKeepInFrameV(sead::LookAtCamera*, const sead::Vector3f&,
                            const al::CameraPoser* cameraPoser, f32, f32);
void initCameraRail(al::CameraPoser* cameraPoser, const al::PlacementInfo&, const char*);
bool tryGetCameraRailArg(f32*, const al::PlacementInfo&, const char*, const char*);
// void getCameraRailPointObjId(al::CameraPoser const*, s32);
bool tryFindNearestLimitRailKeeper(const al::CameraPoser* cameraPoser, const sead::Vector3f&);
void calcCameraRotateStick(sead::Vector2f*, const al::CameraPoser* cameraPoser);
f32 calcCameraRotateStickH(const al::CameraPoser* cameraPoser);
f32 calcCameraRotateStickV(const al::CameraPoser* cameraPoser);
f32 calcCameraRotateStickPower(const al::CameraPoser* cameraPoser);
s32 getStickSensitivityLevel(const al::CameraPoser* cameraPoser);
f32 getStickSensitivityScale(const al::CameraPoser* cameraPoser);
bool isValidGyro(const al::CameraPoser* cameraPoser);
s32 getGyroSensitivityLevel(const al::CameraPoser* cameraPoser);
f32 getGyroSensitivityScale(const al::CameraPoser* cameraPoser);
bool isTriggerCameraResetRotate(const al::CameraPoser* cameraPoser);
bool isHoldCameraZoom(const al::CameraPoser* cameraPoser);
bool isHoldCameraSnapShotZoomIn(const al::CameraPoser* cameraPoser);
bool isHoldCameraSnapShotZoomOut(const al::CameraPoser* cameraPoser);
bool isHoldCameraSnapShotRollLeft(const al::CameraPoser* cameraPoser);
bool isHoldCameraSnapShotRollRight(const al::CameraPoser* cameraPoser);
bool tryCalcCameraSnapShotMoveStick(sead::Vector2f*, const al::CameraPoser* cameraPoser);
bool isPlayerTypeFlyer(const al::CameraPoser* cameraPoser);
bool isPlayerTypeHighSpeedMove(const al::CameraPoser* cameraPoser);
bool isPlayerTypeHighJump(const al::CameraPoser* cameraPoser);
bool isPlayerTypeNotTouchGround(const al::CameraPoser* cameraPoser);
bool isOnRideObj(const al::CameraPoser* cameraPoser);
}  // namespace alCameraPoserFunction
